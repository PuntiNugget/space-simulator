<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Galaxy Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* Basic page setup */
        body {
            background-color: #00001a;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            text-align: center;
        }

        .main-layout-container {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 20px;
        }

        /* The main container for the simulation */
        .solar-system-container {
            position: relative;
            width: 600px;
            height: 600px;
            display: grid;
            place-items: center;
            border: 1px dashed #333;
            overflow: hidden;
            background-color: #00000a; /* Slightly darker inner space */
            cursor: default; /* Default cursor */
        }
        
        #universe {
            position: absolute;
            width: 100%;
            height: 100%;
            will-change: transform;
        }
        
        /* Slingshot SVG Overlay */
        #slingshot-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through */
        }
        #slingshot-line {
            stroke: rgba(255, 255, 255, 0.5);
            stroke-width: 3;
            stroke-dasharray: 5 5;
            display: none; /* Hidden by default */
        }


        /* Tool Styles */
        .tools {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .tool-btn {
            padding: 10px;
            font-size: 24px;
            background-color: #333;
            color: white;
            border: 2px solid #555;
            border-radius: 5px;
            cursor: pointer;
        }
        .tool-btn.active {
            background-color: #fcdc4c;
            color: #000;
            border-color: #fff;
        }

        /* === Body Styles === */
        .celestial-body {
            position: absolute;
            border-radius: 50%;
            transform-origin: center center;
            transition: background-color 0.1s linear;
        }
        
        .debris-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background-color: #aaa;
        }

        .star {
            background-color: #fcdc4c;
        }
        
        .black-hole {
            background-color: #000;
            border: 2px solid #333;
            box-shadow: 0 0 20px #ff8c00, 0 0 30px #ff4500;
        }
        
        .neutron-star {
            background-color: #aaccff;
            box-shadow: 0 0 15px #fff, 0 0 25px #aaccff;
        }
        
        .meteor {
            background-color: #666;
            border: 1px solid #aaa;
            box-shadow: 0 0 5px #fff;
        }

        .planet {
            background-color: #3d91f0;
        }
        
        .habitable-planet {
            background-color: #2b9d4a; /* Green */
            box-shadow: 0 0 10px #5eff8b;
        }
        
        .colony-ship {
            background-color: #fff;
            border: 1px solid #00f;
            border-radius: 0; /* Make it a square */
        }
        
        /* Gravity Indicator Style */
        .gravity-indicator {
            position: absolute;
            border: 2px dotted rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            opacity: 0;
        }
        
        /* Population Label Style */
        .population-label {
            position: absolute;
            top: 100%; /* Position below the planet */
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 10px;
            text-shadow: 0 0 2px black;
            white-space: nowrap;
            pointer-events: none;
            user-select: none;
        }
        
        .satellite-container {
            position: absolute;
            width: 1px;
            height: 1px;
            top: 50%;
            left: 50%;
        }
        .satellite {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ccc;
            border: 1px solid #fff;
            border-radius: 50%;
            transform-origin: 0 0;
        }
        

        /* === UI Form Styles === */
        .controls-panel-left,
        .controls-panel-right {
            width: 280px;
            background-color: #1a1a2a;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        fieldset {
            border: 1px solid #555;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }
        legend {
            color: #fcdc4c;
            font-weight: bold;
        }
        input, select, button {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #777;
            background-color: #333;
            color: white;
            width: 95%;
        }
        label > input {
            width: 100%;
            box-sizing: border-box;
        }
        label[for="body-static"] {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }
        #body-static {
            width: auto;
        }

        button {
            cursor: pointer;
            background-color: #fcdc4c;
            color: #000;
            font-weight: bold;
        }
        button:hover {
            background-color: #fff;
        }
        
        /* Sim Control Styles */
        .sim-controls {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping */
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            gap: 8px; /* Add gap for wrapping */
        }
        .sim-controls button {
            width: 50px;
            font-size: 1.2em;
        }
        .sim-controls span {
            width: 100%;
            text-align: center;
            color: #fcdc4c;
            font-weight: bold;
        }
        
        /* Achievement Toast Styles */
        #achievement-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #fcdc4c; /* Golden yellow */
            color: #000;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #fff;
            box-shadow: 0 0 15px #fcdc4c;
            transform: translateX(110%); /* Off-screen */
            transition: transform 0.4s ease-in-out;
            z-index: 1000;
        }
        #achievement-toast.show {
            transform: translateX(0);
        }
        #achievement-toast h3 {
            margin: 0 0 5px 0;
            padding: 0;
        }
        #achievement-toast p {
            margin: 0;
            padding: 0;
            font-style: italic;
        }

        /* Achievement Menu Modal */
        #achievement-menu-modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
        }
        #achievement-menu-content {
            position: relative;
            background-color: #1a1a2a;
            border: 1px solid #444;
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #close-achievements-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #aaa;
            background: none;
            border: none;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            width: auto;
        }
        #close-achievements-btn:hover {
            color: white;
        }
        #achievement-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #achievement-list li {
            background: #333;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
        }
        #achievement-list li.locked {
            color: #777;
            font-style: italic;
        }
        #delete-achievements-btn {
            background-color: #c1440e;
            color: white;
            margin-top: 20px;
            width: 100%;
        }
        
    </style>
</head>
<body>

    <h1>Physics Galaxy Simulator</h1>

    <div class="main-layout-container">

        <div class="controls-panel-left">
            <fieldset>
                <legend>Tools</legend>
                <div class="tools">
                    <button class="tool-btn active" id="tool-select" title="Select / Move">üëÜ</button>
                    <button class="tool-btn" id="tool-pan" title="Pan View">‚úã</button>
                    <button class="tool-btn" id="tool-picker" title="Picker / Duplicate">üß™</button>
                </div>
            </fieldset>

            <fieldset>
                <legend>Add Celestial Body</legend>
                <select id="body-type">
                    <option value="star">Star</option>
                    <option value="black-hole">Black Hole</option>
                    <option value="neutron-star">Neutron Star</option>
                    <option value="planet">Planet</option>
                    <option value="habitable-planet">Habitable Planet</option>
                </select>
                
                <input type="number" id="body-mass" placeholder="Mass (e.g., Star: 1000)">
                <input type="number" id="body-size" placeholder="Size (px, e.g., 20)">
                
                <label id="color-field">
                    Color:
                    <input type="text" id="body-color" placeholder="e.g., #ff0000">
                </label>
                
                <label id="orbit-field" style="display: none;">
                    Orbit Distance:
                    <input type="number" id="orbit-distance" placeholder="e.g., 100">
                </label>
                
                <label id="static-field" for="body-static" style="display: none;">
                    <input type="checkbox" id="body-static"> Is Static (won't move)
                </label>
                
                <button id="add-body-btn">Add Body</button>
            </fieldset>
        </div>

        <div class="solar-system-container">
            <div id="universe">
                </div>
            
            <svg id="slingshot-svg">
                <line id="slingshot-line" />
            </svg>
        </div>

        <div class="controls-panel-right">

            <fieldset>
                <legend>Achievements</legend>
                <button id="view-achievements-btn">View Achievements</button>
            </fieldset>

            <fieldset>
                <legend>Simulation Control</legend>
                <div class="sim-controls">
                    <button id="slow-down-btn" title="Slow Down">&lt;&lt;</button>
                    <button id="pause-btn" title="Pause">‚ùö‚ùö</button>
                    <button id="speed-up-btn" title="Speed Up">&gt;&gt;</button>
                    <span id="speed-display">Speed: 1.0x</span>
                    
                    <button id="zoom-out-btn" title="Zoom Out">-</button>
                    <button id="zoom-in-btn" title="Zoom In">+</button>
                    <span id="zoom-display">Zoom: 1.0x</span>
                </div>
            </fieldset>

            <fieldset>
                <legend>Manage Galaxies</legend>
                <input type="text" id="galaxy-name" placeholder="Galaxy Name">
                <button id="save-galaxy-btn">Save</button>
                <select id="load-galaxy-menu"></select>
                <button id="load-galaxy-btn">Load</button>
                <button id="clear-galaxy-btn">Clear All</button>
            </fieldset>
            
            <fieldset id="selection-info" style="display: none;">
                <legend>Selection Info</legend>
                <div id="selection-name" style="margin-bottom: 10px;"></div>
                <div id="population-graph-container" style="display: none; margin-top: 10px;">
                    <canvas id="population-chart"></canvas>
                </div>
                <button id="delete-btn" style="background-color: #c1440e; margin-top: 10px;">Delete Body</button>
            </fieldset>
        </div>

    </div> <div id="achievement-toast">
        <h3>üèÜ Achievement Unlocked!</h3>
        <p id="achievement-name"></p>
    </div>
    
    <div id="achievement-menu-modal">
        <div id="achievement-menu-content">
            <button id="close-achievements-btn">&times;</button>
            <h2 style="color: #fcdc4c; margin-top: 0;">Achievements</h2>
            <ul id="achievement-list">
                </ul>
            <button id="delete-achievements-btn">Delete progress</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // === 1. GET ALL DOM ELEMENTS ===
            const container = document.querySelector('.solar-system-container');
            const universe = document.getElementById('universe');
            const slingshotLine = document.getElementById('slingshot-line');
            const toolSelectBtn = document.getElementById('tool-select');
            const toolPanBtn = document.getElementById('tool-pan');
            const toolPickerBtn = document.getElementById('tool-picker');
            const addBodyBtn = document.getElementById('add-body-btn');
            const bodyTypeSelect = document.getElementById('body-type');
            const bodyMassInput = document.getElementById('body-mass');
            const bodySizeInput = document.getElementById('body-size');
            const bodyColorInput = document.getElementById('body-color');
            const orbitDistInput = document.getElementById('orbit-distance');
            const colorField = document.getElementById('color-field');
            const orbitField = document.getElementById('orbit-field');
            const staticField = document.getElementById('static-field');
            const bodyStaticInput = document.getElementById('body-static');
            const saveGalaxyBtn = document.getElementById('save-galaxy-btn');
            const loadGalaxyBtn = document.getElementById('load-galaxy-btn');
            const clearGalaxyBtn = document.getElementById('clear-galaxy-btn');
            const loadGalaxyMenu = document.getElementById('load-galaxy-menu');
            const selectionInfoPanel = document.getElementById('selection-info');
            const selectionName = document.getElementById('selection-name');
            const deleteBtn = document.getElementById('delete-btn');
            const slowDownBtn = document.getElementById('slow-down-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const speedUpBtn = document.getElementById('speed-up-btn');
            const speedDisplay = document.getElementById('speed-display');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const zoomDisplay = document.getElementById('zoom-display');
            
            // Achievement Elements
            const achievementToastEl = document.getElementById('achievement-toast');
            const achievementNameEl = document.getElementById('achievement-name');
            const viewAchievementsBtn = document.getElementById('view-achievements-btn');
            const achievementMenuModal = document.getElementById('achievement-menu-modal');
            const closeAchievementsBtn = document.getElementById('close-achievements-btn');
            const achievementList = document.getElementById('achievement-list');
            const deleteAchievementsBtn = document.getElementById('delete-achievements-btn');
            
            // Graph elements
            const graphContainer = document.getElementById('population-graph-container');
            let populationChart = null; 


            // === 2. CORE SIMULATION STATE ===
            let currentTool = 'select';
            let isMouseDown = false;
            let viewport = { x: 0, y: 0, scale: 1.0 };
            const G = 1;
            const PLANET_TO_STAR_MASS_THRESHOLD = 750;
            const SLINGSHOT_POWER = 0.02; // Reduced power
            const ZOOM_STEP = 0.1;
            const PHYSICS_SUB_STEPS = 5;
            
            // ** UPDATED: Growth Rates **
            const POP_GROWTH_RATE_INITIAL_PER_SEC = 0.001; // 0.1% per second (stagnant)
            const POP_GROWTH_RATE_RAPID_PER_SEC = 0.01;   // 1% per second (rapid)
            const POP_RAPID_GROWTH_THRESHOLD = 10000;      // Pop needed for rapid growth
            const INT_GROWTH_RATE_PER_SEC = 0.01;         // 1% per second (slower)
            const INT_POP_REQUIREMENT = 5000;           // Pop needed for intelligence
            
            const SATELLITE_INT_THRESHOLD = 50;
            
            // Colonization State
            const COLONIZATION_INT_THRESHOLD = 100;
            const COLONIZATION_COOLDOWN = 30000; // 30 seconds
            const COLONY_SHIP_SPEED = 3;
            const COLONY_SHIP_LIFESPAN = 60; // 60 seconds
            
            let currentGalaxy = {
                bodies: [],
                particles: [] 
            };
            
            let bodyElements = new Map();
            let particleElements = new Map();
            let selectedBody = null;
            let isDraggingSlingshot = false;
            let lastMousePos = { x: 0, y: 0 };
            
            let isPaused = false;
            let timeScale = 1.0;
            const timeScaleStep = 0.25;
            
            let lastMeteorCheck = Date.now();
            const METEOR_CHECK_INTERVAL = 10000;
            const METEOR_SPAWN_CHANCE = 0.03;
            
            const ALL_ACHIEVEMENTS = {
                'nom_nom': 'NOM NOM',
                'slingshot': '*wind noises or something*',
                'spaghetti': 'Yummy spaghetti!!',
                'number_one': "I'm number 1",
                'time_warp': 'Time warp',
                'za_warldo': 'ZA WORLDO!',
                'kilonova': 'Kilonova!',
                'civilization': "It's Alive!",
                'colonization': "One Small Step"
            };
            let unlockedAchievements = new Set();


            // === 3. THE PHYSICS & RENDER "GAME LOOP" ===
            
            function simulationLoop() {
                if (isPaused) {
                    return;
                }
                
                const now = Date.now();
                if (now - lastMeteorCheck > METEOR_CHECK_INTERVAL) {
                    lastMeteorCheck = now;
                    if (Math.random() < METEOR_SPAWN_CHANCE) {
                        spawnMeteor();
                    }
                }
                
                updatePhysics();
                
                // Update graph
                if (populationChart && selectedBody && selectedBody.isHabitable) {
                    const history = selectedBody.populationHistory;
                    const newPop = selectedBody.population;
                    history.push(newPop);

                    while (history.length > 50) {
                        history.shift();
                    }
                    
                    populationChart.data.labels = history.map(() => ''); 
                    populationChart.data.datasets[0].data = history;
                    populationChart.update('none'); 
                }
                
                renderGalaxy();
                requestAnimationFrame(simulationLoop);
            }

            function updatePhysics() {
                const gravityWells = currentGalaxy.bodies.filter(b => b.type === 'black-hole' || b.type === 'neutron-star');
                const subTimeStep = timeScale / PHYSICS_SUB_STEPS;
                let bodiesToAdd = []; 
                let bodiesToDestroy = new Set();
                const now = Date.now();
                
                for (let s = 0; s < PHYSICS_SUB_STEPS; s++) {
                    
                    // Phase 1: Calculate all forces
                    for (let i = 0; i < currentGalaxy.bodies.length; i++) {
                        const bodyA = currentGalaxy.bodies[i];
                        bodyA.fx = 0;
                        bodyA.fy = 0;
                        for (let j = 0; j < currentGalaxy.bodies.length; j++) {
                            if (i === j) continue;
                            const bodyB = currentGalaxy.bodies[j];
                            const dx = bodyB.x - bodyA.x;
                            const dy = bodyB.y - bodyA.y;
                            const distSq = (dx * dx + dy * dy) || 1;
                            const dist = Math.sqrt(distSq);
                            const force = (G * bodyA.mass * bodyB.mass) / distSq;
                            bodyA.fx += (force * dx) / dist;
                            bodyA.fy += (force * dy) / dist;
                        }
                    }

                    // Phase 2: Apply physics & growth
                    for (const body of currentGalaxy.bodies) {
                        if (body.isStatic || (isDraggingSlingshot && selectedBody && body.id === selectedBody.id)) {
                            continue;
                        }
                        
                        if (body.type === 'colony-ship') {
                            const target = currentGalaxy.bodies.find(b => b.id === body.targetId);
                            if (target) {
                                // Steer towards target
                                const angle = Math.atan2(target.y - body.y, target.x - body.x);
                                body.vx = Math.cos(angle) * COLONY_SHIP_SPEED;
                                body.vy = Math.sin(angle) * COLONY_SHIP_SPEED;
                            } else {
                                body.life = 0; // Target destroyed, despawn
                            }
                        } else {
                            // Regular gravity physics
                            const ax = body.fx / body.mass;
                            const ay = body.fy / body.mass;
                            body.vx += ax * subTimeStep;
                            body.vy += ay * subTimeStep;
                        }
                        
                        body.x += body.vx * subTimeStep;
                        body.y += body.vy * subTimeStep;
                        
                        if (body.type === 'meteor' || body.type === 'colony-ship') {
                            body.life -= subTimeStep;
                            if (body.life <= 0) {
                                bodiesToDestroy.add(body.id);
                            }
                        }
                        
                        // ** UPDATED: Continuous Exponential Growth **
                        if (body.isHabitable && body.population > 0) {
                            let popGrowthRate;
                            if (body.population < POP_RAPID_GROWTH_THRESHOLD) {
                                popGrowthRate = POP_GROWTH_RATE_INITIAL_PER_SEC; // Stagnant
                            } else {
                                popGrowthRate = POP_GROWTH_RATE_RAPID_PER_SEC; // Rapid
                            }
                            const popGrowth = body.population * (popGrowthRate * subTimeStep);
                            body.population += popGrowth;
                            
                            // Exponential intelligence growth (if conditions are met)
                            if (body.population > INT_POP_REQUIREMENT) { 
                                if (body.intelligence < 1) body.intelligence = 1; 
                                const intelGrowth = body.intelligence * (INT_GROWTH_RATE_PER_SEC * subTimeStep);
                                body.intelligence += intelGrowth;
                            }
                        }
                    }

                    // Phase 2.5: Orbital Decay (Spiral)
                    if (gravityWells.length > 0) {
                        for (const body of currentGalaxy.bodies) {
                            if (body.isStatic || body.type === 'black-hole' || body.type === 'neutron-star') continue;

                            let closestWell = null;
                            let minDistSq = Infinity;
                            for (const well of gravityWells) {
                                const dx = well.x - body.x;
                                const dy = well.y - body.y;
                                const distSq = (dx * dx + dy * dy);
                                if (distSq < minDistSq) {
                                    minDistSq = distSq;
                                    closestWell = well;
                                }
                            }

                            if (closestWell) {
                                const pullRadiusSq = Math.pow(closestWell.mass / 10, 2); 
                                if (minDistSq < pullRadiusSq) {
                                    const dragFactor = (pullRadiusSq - minDistSq) / pullRadiusSq; 
                                    const decay = 1.0 - (0.005 * dragFactor * subTimeStep); 
                                    body.vx *= decay;
                                    body.vy *= decay;
                                }
                            }
                        }
                    }
                    
                    // Phase 2.7: Particle Physics
                    for (const p of currentGalaxy.particles) {
                        p.x += p.vx * subTimeStep;
                        p.y += p.vy * subTimeStep;
                        p.life -= 0.02 * subTimeStep; 
                    }
                } // ** End of sub-step loop **
                
                // --- These things run ONCE per frame, after physics ---
                
                // Phase 2.6: Habitable Planet *Intelligence* Growth (per orbit)
                if (currentGalaxy.bodies.length > 1) {
                    let centralBody = currentGalaxy.bodies[0];
                    for(let i=1; i<currentGalaxy.bodies.length; i++) {
                        if(currentGalaxy.bodies[i].mass > centralBody.mass) {
                            centralBody = currentGalaxy.bodies[i];
                        }
                    }
                    
                    for (const body of currentGalaxy.bodies) {
                        if (body.isHabitable && body.id !== centralBody.id) {
                            const dx = body.x - centralBody.x;
                            const dy = body.y - centralBody.y;
                            const currentAngle = Math.atan2(dy, dx);
                            
                            if (body.lastAngle > 0 && currentAngle <= 0) {
                                // Check for Satellite launch
                                if (body.intelligence >= SATELLITE_INT_THRESHOLD && !body.hasSatellites) {
                                    body.hasSatellites = true;
                                    unlockAchievement('civilization', "It's Alive!");
                                }
                            }
                            body.lastAngle = currentAngle;
                            
                            // Colonization Logic
                            if (body.intelligence >= COLONIZATION_INT_THRESHOLD && now - body.lastColonizationAttempt > COLONIZATION_COOLDOWN) {
                                body.lastColonizationAttempt = now;
                                const target = findColonizationTarget(body);
                                if (target) {
                                    spawnColonyShip(body, target, bodiesToAdd);
                                }
                            }
                        }
                    }
                }


                // Phase 3: Collision Detection & Resolution
                let supernovaEvents = [];

                for (let i = 0; i < currentGalaxy.bodies.length; i++) {
                    const bodyA = currentGalaxy.bodies[i];
                    if (bodiesToDestroy.has(bodyA.id)) continue; 

                    for (let j = i + 1; j < currentGalaxy.bodies.length; j++) {
                        const bodyB = currentGalaxy.bodies[j];
                        if (bodiesToDestroy.has(bodyB.id)) continue;

                        const dx = bodyB.x - bodyA.x;
                        const dy = bodyB.y - bodyA.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const collisionDist = (bodyA.size / 2) + (bodyB.size / 2);

                        if (dist < collisionDist) {
                            let survivor, victim;
                            const isA_NS = bodyA.type === 'neutron-star';
                            const isB_NS = bodyB.type === 'neutron-star';
                            const isA_Meteor = bodyA.type === 'meteor';
                            const isB_Meteor = bodyB.type === 'meteor';
                            const isA_Ship = bodyA.type === 'colony-ship';
                            const isB_Ship = bodyB.type === 'colony-ship';
                            
                            // 1. Meteor Collisions (always die)
                            if (isA_Meteor || isB_Meteor) {
                                const meteor = isA_Meteor ? bodyA : bodyB;
                                const target = isA_Meteor ? bodyB : bodyA;
                                bodiesToDestroy.add(meteor.id);
                                if (target.isHabitable) {
                                    target.population = Math.floor(target.population * 0.9); // 10% loss
                                }
                                spawnDebris(meteor.x, meteor.y, meteor.color, target.color);
                                continue;
                            }
                            
                            // 2. Colony Ship Collisions
                            if (isA_Ship || isB_Ship) {
                                const ship = isA_Ship ? bodyA : bodyB;
                                const target = isA_Ship ? bodyB : bodyA;
                                
                                if (target.id === ship.targetId && target.type === 'planet') {
                                    // ** Successful Colonization! (BUG FIX) **
                                    target.type = 'habitable-planet';
                                    target.isHabitable = true;
                                    target.population = 1000;
                                    target.intelligence = 0;
                                    target.populationHistory = [];
                                    target.color = '#2b9d4a';
                                    target.hasSatellites = false;
                                    target.lastColonizationAttempt = 0;
                                }
                                bodiesToDestroy.add(ship.id); // Ship is always destroyed
                                continue;
                            }
                            
                            // 3. Kilonova
                            if (isA_NS && isB_NS) {
                                handleKilonova(bodyA, bodyB, bodiesToDestroy, bodiesToAdd);
                                continue; 
                            
                            // 4. Black Hole wins all
                            } else if (bodyA.type === 'black-hole') {
                                survivor = bodyA; victim = bodyB;
                                mergeBodies(survivor, victim, bodiesToDestroy, supernovaEvents);
                            
                            } else if (bodyB.type === 'black-hole') {
                                survivor = bodyB; victim = bodyA;
                                mergeBodies(survivor, victim, bodiesToDestroy, supernovaEvents);
                            
                            // 5. Neutron Star wins non-BH
                            } else if (isA_NS) {
                                survivor = bodyA; victim = bodyB;
                                mergeBodies(survivor, victim, bodiesToDestroy, supernovaEvents);
                            
                            } else if (isB_NS) {
                                survivor = bodyB; victim = bodyA;
                                mergeBodies(survivor, victim, bodiesToDestroy, supernovaEvents);
                            
                            } else {
                                // --- NO Black Hole or Neutron Star involved ---
                                const isA_Hab = bodyA.type === 'habitable-planet';
                                const isB_Hab = bodyB.type === 'habitable-planet';
                                const isA_Planet = bodyA.type === 'planet';
                                const isB_Planet = bodyB.type === 'planet';

                                // Non-lethal: (hab + hab) OR (hab + planet)
                                if ( (isA_Hab && isB_Hab) || (isA_Hab && isB_Planet) || (isB_Hab && isA_Planet) ) {
                                    const wipeout = 0.9 + (Math.random() * 0.1); 
                                    if (isA_Hab) bodyA.population = Math.floor(bodyA.population * (1.0 - wipeout));
                                    if (isB_Hab) bodyB.population = Math.floor(bodyB.population * (1.0 - wipeout));
                                    spawnDebris(bodyA.x, bodyA.y, bodyA.color, bodyB.color);
                                    continue; // Skip merging
                                }
                                
                                // LETHAL merge: Mass wins
                                if (bodyA.mass >= bodyB.mass) {
                                    survivor = bodyA;
                                    victim = bodyB;
                                } else {
                                    survivor = bodyB;
                                    victim = bodyA;
                                }
                                mergeBodies(survivor, victim, bodiesToDestroy, supernovaEvents);
                            }
                        }
                    }
                }
                
                // Phase 3.5 - Process Supernovas
                if (supernovaEvents.length > 0) {
                    for (const novaStar of supernovaEvents) {
                        const blastDiameter = (novaStar.size * 1.5) + (novaStar.mass / 20);
                        const blastRadius = blastDiameter / 2;
                        
                        for (const body of currentGalaxy.bodies) {
                            if (body.type === 'planet' && !bodiesToDestroy.has(body.id)) {
                                const dx = body.x - novaStar.x;
                                const dy = body.y - novaStar.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist <= blastRadius) {
                                    bodiesToDestroy.add(body.id);
                                }
                            }
                        }
                    }
                }
                
                // Phase 4: Clean up destroyed bodies
                if (bodiesToDestroy.size > 0) {
                    currentGalaxy.bodies = currentGalaxy.bodies.filter(body => {
                        return !bodiesToDestroy.has(body.id);
                    });
                    
                    for (const id of bodiesToDestroy) {
                        const el = bodyElements.get(id);
                        if (el) el.remove();
                        bodyElements.delete(id);
                    }
                    
                    if (selectedBody && bodiesToDestroy.has(selectedBody.id)) {
                        selectBody(null);
                    }
                }
                
                // Add newly created bodies
                if (bodiesToAdd.length > 0) {
                    currentGalaxy.bodies.push(...bodiesToAdd);
                }
                
                // Phase 5: Clean up dead particles
                currentGalaxy.particles = currentGalaxy.particles.filter(p => {
                    if (p.life <= 0) {
                        const el = particleElements.get(p.id);
                        if (el) el.remove();
                        particleElements.delete(p.id);
                        return false;
                    }
                    return true;
                });
            }
            
            function handleKilonova(bodyA, bodyB, bodiesToDestroy, bodiesToAdd) {
                bodiesToDestroy.add(bodyA.id);
                bodiesToDestroy.add(bodyB.id);

                const newMass = bodyA.mass + bodyB.mass;
                const newBH = {
                    id: Date.now(),
                    type: 'black-hole',
                    mass: newMass,
                    size: 30, 
                    x: (bodyA.x + bodyB.x) / 2,
                    y: (bodyA.y + bodyB.y) / 2,
                    vx: ((bodyA.mass * bodyA.vx) + (bodyB.mass * bodyB.vx)) / newMass,
                    vy: ((bodyA.mass * bodyA.vy) + (bodyB.mass * bodyB.vy)) / newMass,
                    fx: 0, fy: 0,
                    isStatic: false,
                    isHabitable: false,
                    population: 0,
                    lastAngle: 0,
                    intelligence: 0,
                    hasSatellites: false,
                    populationHistory: [],
                    lastColonizationAttempt: 0
                };
                bodiesToAdd.push(newBH);
                unlockAchievement('kilonova', 'Kilonova!');
            }
            
            function spawnDebris(x, y, color1, color2) {
                const numParticles = 20;
                for (let i = 0; i < numParticles; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const speed = Math.random() * 3 + 1; 
                    
                    const particle = {
                        id: Date.now() + Math.random(),
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0, 
                        color: (i % 2 === 0) ? color1 : color2
                    };
                    currentGalaxy.particles.push(particle);
                }
            }
            
            function spawnMeteor() {
                const size = Math.random() * 5 + 3; // 3-8px
                const mass = size * 2; 
                
                const side = Math.floor(Math.random() * 4);
                const spawnDist = 400 / viewport.scale; 
                
                let x, y, vx, vy;
                
                const targetX = viewport.x + (Math.random() - 0.5) * 200;
                const targetY = viewport.y + (Math.random() - 0.5) * 200;

                if (side === 0) { // Top
                    x = viewport.x + (Math.random() - 0.5) * 800;
                    y = viewport.y - spawnDist;
                } else if (side === 1) { // Right
                    x = viewport.x + spawnDist;
                    y = viewport.y + (Math.random() - 0.5) * 800;
                } else if (side === 2) { // Bottom
                    x = viewport.x + (Math.random() - 0.5) * 800;
                    y = viewport.y + spawnDist;
                } else { // Left
                    x = viewport.x - spawnDist;
                    y = viewport.y + (Math.random() - 0.5) * 800;
                }
                
                const speed = (Math.random() * 5 + 5);
                const angle = Math.atan2(targetY - y, targetX - x);
                vx = Math.cos(angle) * speed;
                vy = Math.sin(angle) * speed;

                const meteor = {
                    id: Date.now() + Math.random(),
                    type: 'meteor',
                    mass: mass,
                    size: size,
                    color: '#666',
                    x: x, y: y, vx: vx, vy: vy, fx: 0, fy: 0,
                    isStatic: false,
                    isHabitable: false,
                    life: 30, 
                    populationHistory: [],
                    lastColonizationAttempt: 0
                };
                currentGalaxy.bodies.push(meteor);
            }
            
            function spawnColonyShip(origin, target, bodiesToAdd) {
                unlockAchievement('colonization', 'One Small Step');
                
                const ship = {
                    id: Date.now() + Math.random(),
                    type: 'colony-ship',
                    mass: 0.1, 
                    size: 5,
                    color: '#fff',
                    x: origin.x,
                    y: origin.y,
                    vx: 0, 
                    vy: 0,
                    fx: 0, fy: 0,
                    isStatic: false,
                    isHabitable: false,
                    life: COLONY_SHIP_LIFESPAN,
                    targetId: target.id, 
                    populationHistory: [],
                    lastColonizationAttempt: 0
                };
                bodiesToAdd.push(ship);
            }
            
            
            function mergeBodies(survivor, victim, bodiesToDestroy, supernovaEvents) {
                const vicType = victim.type;
                const survType = survivor.type;

                if (survType === 'black-hole' && vicType !== 'black-hole') {
                    unlockAchievement('spaghetti', 'Yummy spaghetti!!');
                } else if ((survType === 'star' || survType === 'neutron-star') && (vicType === 'planet' || vicType === 'habitable-planet')) {
                    unlockAchievement('nom_nom', 'NOM NOM');
                } else if ((survType === 'planet' || survType === 'habitable-planet') && (vicType === 'star' || vicType === 'neutron-star')) {
                    unlockAchievement('number_one', "I'm number 1");
                }

                if (survType === 'black-hole') {
                    survivor.isStatic = false; 
                }

                const newMass = survivor.mass + victim.mass;
                survivor.vx = ((survivor.mass * survivor.vx) + (victim.mass * victim.vx)) / newMass;
                survivor.vy = ((survivor.mass * survivor.vy) + (victim.mass * victim.vy)) / newMass;
                survivor.mass = newMass;
                
                if (survType !== 'black-hole') {
                    survivor.size = Math.sqrt(Math.pow(survivor.size, 2) + Math.pow(victim.size, 2));
                }
                
                if (survivor.isHabitable && victim.isHabitable) {
                    survivor.population += victim.population;
                    survivor.populationHistory.push(...victim.populationHistory); 
                }
                
                bodiesToDestroy.add(victim.id);
                
                if (survType === 'star' && vicType === 'star') {
                    supernovaEvents.push(survivor);
                }
                
                if ((survType === 'planet' || survType === 'habitable-planet') && survivor.mass >= PLANET_TO_STAR_MASS_THRESHOLD) {
                    survivor.type = 'star';
                    survivor.color = '#fcdc4c';
                    survivor.isHabitable = false;
                }
            }

            /**
             * Renders bodies, particles, and satellites
             */
            function renderGalaxy() {
                const viewX = -viewport.x + 300;
                const viewY = -viewport.y + 300;
                universe.style.transform = `translate(${viewX}px, ${viewY}px) scale(${viewport.scale})`;
                
                const blackHoles = currentGalaxy.bodies.filter(b => b.type === 'black-hole');
                
                // --- 1. Render Bodies ---
                for (const body of currentGalaxy.bodies) {
                    let el = bodyElements.get(body.id);
                    let indicatorEl, labelEl, satContainer; 
                    
                    if (!el) {
                        el = document.createElement('div');
                        indicatorEl = document.createElement('div');
                        indicatorEl.className = 'gravity-indicator';
                        el.appendChild(indicatorEl); 
                        
                        if (body.isHabitable) {
                            labelEl = document.createElement('div');
                            labelEl.className = 'population-label';
                            el.appendChild(labelEl);
                            satContainer = document.createElement('div');
                            satContainer.className = 'satellite-container';
                            el.appendChild(satContainer);
                        }
                        
                        bodyElements.set(body.id, el);
                        universe.appendChild(el);
                    } else {
                        indicatorEl = el.querySelector('.gravity-indicator');
                        labelEl = el.querySelector('.population-label'); 
                        satContainer = el.querySelector('.satellite-container');
                    }
                    
                    el.className = 'celestial-body ' + body.type;
                    
                    const elX = body.x - (body.size / 2);
                    const elY = body.y - (body.size / 2);
                    let transform = `translate(${elX}px, ${elY}px)`; 
                    
                    let isSpaghettified = false;
                    
                    if (body.type !== 'black-hole' && body.type !== 'neutron-star' && blackHoles.length > 0) {
                        let closestBH = null;
                        let minDistSq = Infinity;
                        for (const bh of blackHoles) {
                            const dx = bh.x - body.x;
                            const dy = bh.y - body.y;
                            const distSq = (dx * dx + dy * dy);
                            if (distSq < minDistSq) {
                                minDistSq = distSq;
                                closestBH = bh;
                            }
                        }
                        
                        if (closestBH) {
                            const dist = Math.sqrt(minDistSq);
                            const spagDist = closestBH.size * 3; 
                            
                            if (dist < spagDist) {
                                isSpaghettified = true;
                                const angle = Math.atan2(closestBH.y - body.y, closestBH.x - body.x);
                                
                                el.style.backgroundColor = 'transparent';
                                if (labelEl) labelEl.style.display = 'none'; 
                                if (satContainer) satContainer.style.display = 'none';
                                el.style.width = `${body.size}px`; 
                                el.style.height = `${body.size}px`;
                                
                                indicatorEl.style.border = 'none';
                                indicatorEl.style.borderRadius = '50%';
                                const arcSize = body.size * 2 + (spagDist - dist);
                                indicatorEl.style.width = `${arcSize}px`;
                                indicatorEl.style.height = `${arcSize}px`;
                                indicatorEl.style.opacity = '1';
                                indicatorEl.style.borderTop = `3px solid ${body.color}`;
                                indicatorEl.style.transform = `translate(-50%, -50%) rotate(${angle + Math.PI}rad)`;
                            }
                        }
                    }
                    
                    if (!isSpaghettified) {
                        el.style.backgroundColor = body.color;
                        if (labelEl) labelEl.style.display = 'block'; 
                        if (satContainer) satContainer.style.display = 'block';
                        el.style.width = `${body.size}px`;
                        el.style.height = `${body.size}px`;
                        
                        const indicatorOpacity = Math.min(0.8, body.mass / 1500); 
                        const indicatorSize = (body.size * 1.5) + (body.mass / 20);
                        indicatorEl.style.border = '2px dotted rgba(255, 255, 255, 0.8)';
                        indicatorEl.style.width = `${indicatorSize}px`;
                        indicatorEl.style.height = `${indicatorSize}px`;
                        indicatorEl.style.opacity = indicatorOpacity;
                        indicatorEl.style.transform = 'translate(-50%, -50%)';
                    }
                    
                    if (labelEl && body.isHabitable) {
                        labelEl.textContent = `Pop: ${body.population.toLocaleString(undefined, { maximumFractionDigits: 0 })} Int: ${body.intelligence.toFixed(1)}`;
                    }
                    
                    if (satContainer) {
                        if (body.isHabitable && body.intelligence >= SATELLITE_INT_THRESHOLD && !body.hasSatellites) {
                            body.hasSatellites = true;
                            unlockAchievement('civilization', "It's Alive!");
                        }
                    
                        if (body.hasSatellites && satContainer.childElementCount === 0) {
                            for (let i = 0; i < 3; i++) {
                                const satEl = document.createElement('div');
                                satEl.className = 'satellite';
                                satContainer.appendChild(satEl);
                            }
                        }
                        
                        if (satContainer.childElementCount > 0) {
                            const satellites = satContainer.querySelectorAll('.satellite');
                            satellites.forEach((sat, i) => {
                                const angle = (Date.now() / 1000) * (1 + i * 0.5);
                                const orbit = (body.size / 2) + 6 + (i * 4);
                                sat.style.transform = `rotate(${angle}rad) translateX(${orbit}px)`;
                            });
                        }
                    }
                    
                    
                    el.style.transform = transform;

                    if (selectedBody && selectedBody.id === body.id) {
                        el.style.border = '2px solid cyan';
                    } else {
                        el.style.border = 'none'; 
                        if (body.type === 'black-hole') {
                            el.style.border = '2px solid #333';
                        }
                    }
                }
                
                // --- 2. Render Particles ---
                for (const p of currentGalaxy.particles) {
                    let el = particleElements.get(p.id);
                    if (!el) {
                        el = document.createElement('div');
                        el.className = 'debris-particle';
                        particleElements.set(p.id, el);
                        universe.appendChild(el);
                    }
                    el.style.backgroundColor = p.color;
                    el.style.opacity = p.life;
                    el.style.transform = `translate(${p.x}px, ${p.y}px)`;
                }
            }
            
            
            // === 4. UI EVENT LISTENERS ===
            
            // --- Tool Selection ---
            function setActiveTool(tool) {
                currentTool = tool;
                toolSelectBtn.classList.remove('active');
                toolPanBtn.classList.remove('active');
                toolPickerBtn.classList.remove('active');
                document.getElementById(`tool-${tool}`).classList.add('active');
                
                if (tool === 'pan') {
                    container.style.cursor = 'grab';
                } else {
                    container.style.cursor = 'default';
                }
            }
            toolSelectBtn.onclick = () => setActiveTool('select');
            toolPanBtn.onclick = () => setActiveTool('pan');
            toolPickerBtn.onclick = () => setActiveTool('picker');

            // --- Smart Form Function ---
            function updateAddForm() {
                const type = bodyTypeSelect.value;
                if (type === 'star') {
                    colorField.style.display = 'block';
                    orbitField.style.display = 'none';
                    staticField.style.display = 'block'; 
                    bodyMassInput.placeholder = "Mass (default: 1000)";
                    bodySizeInput.placeholder = "Size (default: 50)";
                    bodyColorInput.value = '#fcdc4c';
                } else if (type === 'black-hole') {
                    colorField.style.display = 'none';
                    orbitField.style.display = 'none';
                    staticField.style.display = 'block'; 
                    bodyMassInput.placeholder = "Mass (default: 20000)";
                    bodySizeInput.placeholder = "Size (default: 30)";
                    bodyColorInput.value = '#000000';
                } else if (type === 'neutron-star') {
                    colorField.style.display = 'none';
                    orbitField.style.display = 'none';
                    staticField.style.display = 'block'; 
                    bodyMassInput.placeholder = "Mass (default: 10000)";
                    bodySizeInput.placeholder = "Size (default: 8)";
                    bodyColorInput.value = '#aaccff';
                } else if (type === 'planet') {
                    colorField.style.display = 'block';
                    orbitField.style.display = 'block';
                    staticField.style.display = 'none'; 
                    bodyStaticInput.checked = false; 
                    bodyMassInput.placeholder = "Mass (default: 10)";
                    bodySizeInput.placeholder = "Size (default: 12)";
                    orbitDistInput.placeholder = "Orbit (default: 150)";
                    bodyColorInput.value = '#3d91f0';
                } else if (type === 'habitable-planet') {
                    colorField.style.display = 'block';
                    orbitField.style.display = 'block';
                    staticField.style.display = 'none'; 
                    bodyStaticInput.checked = false; 
                    bodyMassInput.placeholder = "Mass (default: 15)";
                    bodySizeInput.placeholder = "Size (default: 15)";
                    orbitDistInput.placeholder = "Orbit (default: 200)";
                    bodyColorInput.value = '#2b9d4a'; // Green
                }
            }
            bodyTypeSelect.addEventListener('change', updateAddForm);
            
            
            // --- Add Body Listener (with defaults) ---
            addBodyBtn.addEventListener('click', () => {
                const type = bodyTypeSelect.value;
                const rawMass = bodyMassInput.value;
                const rawSize = bodySizeInput.value;
                const rawColor = bodyColorInput.value;
                const rawOrbitDist = orbitDistInput.value;

                let newBody = {
                    id: Date.now(),
                    type: type,
                    x: 0, y: 0, vx: 0, vy: 0, fx: 0, fy: 0,
                    isStatic: bodyStaticInput.checked,
                    isHabitable: false,
                    population: 0,
                    lastAngle: 0,
                    intelligence: 0,
                    hasSatellites: false,
                    populationHistory: [],
                    lastColonizationAttempt: 0 
                };

                if (type === 'star') {
                    newBody.mass = parseFloat(rawMass) || 1000;
                    newBody.size = parseFloat(rawSize) || 50;
                    newBody.color = rawColor || '#fcdc4c';
                } else if (type === 'black-hole') {
                    newBody.mass = parseFloat(rawMass) || 20000;
                    newBody.size = parseFloat(rawSize) || 30;
                    newBody.color = '#000000';
                } else if (type === 'neutron-star') {
                    newBody.mass = parseFloat(rawMass) || 10000;
                    newBody.size = parseFloat(rawSize) || 8;
                    newBody.color = rawColor || '#aaccff';
                } else if (type === 'planet') {
                    newBody.mass = parseFloat(rawMass) || 10;
                    newBody.size = parseFloat(rawSize) || 12;
                    newBody.color = rawColor || '#3d91f0';
                } else if (type === 'habitable-planet') {
                    newBody.mass = parseFloat(rawMass) || 15;
                    newBody.size = parseFloat(rawSize) || 15;
                    newBody.color = rawColor || '#2b9d4a';
                    newBody.isHabitable = true;
                    newBody.population = 1000; 
                }
                
                // ** UPDATED: Orbital logic for all non-static bodies **
                if (!newBody.isStatic && currentGalaxy.bodies.length > 0) {
                    let centralBody = currentGalaxy.bodies[0];
                    for(let i=1; i<currentGalaxy.bodies.length; i++) {
                        if(currentGalaxy.bodies[i].mass > centralBody.mass) {
                            centralBody = currentGalaxy.bodies[i];
                        }
                    }
                    
                    let orbitDist = parseFloat(rawOrbitDist);
                    if (!orbitDist) {
                        if (type === 'habitable-planet') orbitDist = 200;
                        else if (type === 'planet') orbitDist = 150;
                        else orbitDist = 250; // Default for stars, NS, BH
                    }
                    
                    newBody.x = centralBody.x + orbitDist;
                    newBody.y = centralBody.y;
                    
                    newBody.lastAngle = Math.atan2(newBody.y - centralBody.y, newBody.x - centralBody.x);
                    
                    const v = Math.sqrt((G * centralBody.mass) / orbitDist);
                    newBody.vy = -v;
                }
                
                currentGalaxy.bodies.push(newBody);
                bodyMassInput.value = '';
                bodySizeInput.value = '';
                orbitDistInput.value = '';
                bodyStaticInput.checked = false; 
                updateAddForm();
            });

            // --- Save/Load Functions ---
            saveGalaxyBtn.addEventListener('click', () => {
                const galaxyName = document.getElementById('galaxy-name').value;
                if (!galaxyName) return alert('Please enter a name!');
                const saveData = { bodies: currentGalaxy.bodies, viewport: viewport };
                localStorage.setItem(galaxyName, JSON.stringify(saveData));
                alert(`Galaxy "${galaxyName}" saved!`);
                populateLoadMenu();
            });
            
            // ** UPDATED: Load function now adds all new properties **
            loadGalaxyBtn.addEventListener('click', () => {
                const galaxyName = loadGalaxyMenu.value;
                if (!galaxyName) return alert('Please select a galaxy.');
                const savedData = JSON.parse(localStorage.getItem(galaxyName));
                clearAll(); 
                currentGalaxy.bodies = savedData.bodies;
                currentGalaxy.bodies.forEach(body => {
                    body.populationHistory = body.populationHistory || [];
                    body.intelligence = body.intelligence || 0;
                    body.hasSatellites = body.hasSatellites || false;
                    body.lastColonizationAttempt = body.lastColonizationAttempt || 0;
                });
                viewport = savedData.viewport || { x: 0, y: 0, scale: 1.0 };
                renderGalaxy(); 
                alert(`Galaxy "${galaxyName}" loaded!`);
            });
            clearGalaxyBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to clear the current galaxy?')) {
                    clearAll();
                }
            });
            function clearAll() {
                currentGalaxy.bodies = [];
                currentGalaxy.particles = []; 
                universe.innerHTML = '';
                bodyElements.clear();
                particleElements.clear(); 
                viewport = { x: 0, y: 0, scale: 1.0 };
                selectBody(null);
                renderGalaxy(); 
            }
            function populateLoadMenu() {
                loadGalaxyMenu.innerHTML = '';
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = key;
                    loadGalaxyMenu.appendChild(option);
                }
            }
            
            // --- Selection Panel Logic ---
            deleteBtn.addEventListener('click', () => {
                if (selectedBody) {
                    const bodiesToDestroy = new Set([selectedBody.id]);
                    currentGalaxy.bodies = currentGalaxy.bodies.filter(body => {
                        return !bodiesToDestroy.has(body.id);
                    });
                    const el = bodyElements.get(selectedBody.id);
                    if (el) el.remove();
                    bodyElements.delete(selectedBody.id);
                    selectBody(null);
                }
            });
            
            function selectBody(body) {
                selectedBody = body;
                
                if (populationChart) {
                    populationChart.destroy();
                    populationChart = null;
                }
                
                if (body) {
                    selectionInfoPanel.style.display = 'block';
                    let name = `${body.type} (Mass: ${body.mass.toFixed(0)})`;
                    if (body.isHabitable) {
                        name += ` (Pop: ${body.population.toLocaleString(undefined, { maximumFractionDigits: 0 })} Int: ${body.intelligence.toFixed(1)})`;
                        graphContainer.style.display = 'block';
                        initPopulationChart(body);
                    } else {
                        graphContainer.style.display = 'none';
                    }
                    selectionName.textContent = name;
                } else {
                    selectionInfoPanel.style.display = 'none';
                    selectionName.textContent = '';
                    graphContainer.style.display = 'none';
                }
            }
            
            function initPopulationChart(body) {
                const ctx = document.getElementById('population-chart').getContext('2d');
                const history = body.populationHistory || [];
                
                populationChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: history.map(() => ''),
                        datasets: [{
                            label: 'Population',
                            data: history,
                            borderColor: '#2b9d4a',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: true,
                            backgroundColor: 'rgba(43, 157, 74, 0.3)'
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                beginAtZero: false, 
                                ticks: { color: '#fff' }
                            },
                            x: {
                                ticks: { display: false }
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        },
                        animation: false 
                    }
                });
            }


            function findBodyAt(x, y) {
                for (let i = currentGalaxy.bodies.length - 1; i >= 0; i--) {
                    const body = currentGalaxy.bodies[i];
                    const dx = body.x - x;
                    const dy = body.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < body.size / 2) {
                        return body;
                    }
                }
                return null;
            }

            // --- Achievement System Functions ---
            function loadAchievements() {
                const saved = localStorage.getItem('galaxySimAchievements');
                if (saved) {
                    unlockedAchievements = new Set(JSON.parse(saved));
                }
            }
            function saveAchievements() {
                localStorage.setItem('galaxySimAchievements', JSON.stringify([...unlockedAchievements]));
            }
            function unlockAchievement(id, name) {
                if (unlockedAchievements.has(id)) {
                    return; // Already unlocked
                }
                unlockedAchievements.add(id);
                saveAchievements();
                
                achievementNameEl.textContent = `"${name}"`;
                achievementToastEl.classList.add('show');
                
                setTimeout(() => {
                    achievementToastEl.classList.remove('show');
                }, 4000); // 4 seconds
            }
            
            function populateAchievementsMenu() {
                achievementList.innerHTML = ''; // Clear old list
                
                for (const id in ALL_ACHIEVEMENTS) {
                    const name = ALL_ACHIEVEMENTS[id];
                    const li = document.createElement('li');
                    
                    if (unlockedAchievements.has(id)) {
                        li.textContent = `üèÜ ${name}`;
                    } else {
                        li.textContent = `üîí ${name}`;
                        li.classList.add('locked');
                    }
                    achievementList.appendChild(li);
                }
            }
            
            function showAchievementsMenu() {
                populateAchievementsMenu();
                achievementMenuModal.style.display = 'flex';
            }
            
            function hideAchievementsMenu() {
                achievementMenuModal.style.display = 'none';
            }
            
            // --- Achievement Menu Listeners ---
            viewAchievementsBtn.addEventListener('click', showAchievementsMenu);
            closeAchievementsBtn.addEventListener('click', hideAchievementsMenu);
            deleteAchievementsBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to delete all achievement progress? This cannot be undone.')) {
                    unlockedAchievements.clear();
                    saveAchievements();
                    populateAchievementsMenu(); // Refresh the list
                }
            });
            achievementMenuModal.addEventListener('click', (e) => {
                if (e.target === achievementMenuModal) {
                    hideAchievementsMenu();
                }
            });


            
            // === 5. MOUSE CONTROLS (with Slingshot & Zoom) ===
            
            function getUniverseCoords(e) {
                const rect = container.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                
                const universeX = (screenX - 300) / viewport.scale + viewport.x;
                const universeY = (screenY - 300) / viewport.scale + viewport.y;
                return { x: universeX, y: universeY, screenX, screenY };
            }
            
            container.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                lastMousePos = { x: e.clientX, y: e.clientY };
                const coords = getUniverseCoords(e);
                
                if (currentTool === 'select') {
                    const clickedBody = findBodyAt(coords.x, coords.y);
                    selectBody(clickedBody);
                    
                    if (clickedBody && !clickedBody.isStatic) {
                        isDraggingSlingshot = true;
                        clickedBody.vx = 0; 
                        clickedBody.vy = 0;
                        
                        const bodyScreenX = (clickedBody.x - viewport.x) * viewport.scale + 300;
                        const bodyScreenY = (clickedBody.y - viewport.y) * viewport.scale + 300;
                        slingshotLine.setAttribute('x1', bodyScreenX);
                        slingshotLine.setAttribute('y1', bodyScreenY);
                        slingshotLine.setAttribute('x2', coords.screenX);
                        slingshotLine.setAttribute('y2', coords.screenY);
                        slingshotLine.style.display = 'block';
                    }
                } else if (currentTool === 'pan') {
                    container.style.cursor = 'grabbing';
                } else if (currentTool === 'picker') {
                    const clickedBody = findBodyAt(coords.x, coords.y);
                    if (clickedBody) {
                        const newBody = JSON.parse(JSON.stringify(clickedBody));
                        newBody.id = Date.now(); 
                        newBody.x += newBody.size; 
                        newBody.isStatic = false; 
                        currentGalaxy.bodies.push(newBody);
                    }
                }
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;

                const newMousePos = { x: e.clientX, y: e.clientY };
                const deltaX = newMousePos.x - lastMousePos.x;
                const deltaY = newMousePos.y - lastMousePos.y;
                
                if (currentTool === 'pan') {
                    viewport.x -= deltaX / viewport.scale;
                    viewport.y -= deltaY / viewport.scale;
                } else if (currentTool === 'select' && isDraggingSlingshot) {
                    const coords = getUniverseCoords(e);
                    slingshotLine.setAttribute('x2', coords.screenX);
                    slingshotLine.setAttribute('y2', coords.screenY);
                }
                
                lastMousePos = newMousePos;
            });
            
            container.addEventListener('mouseup', (e) => {
                isMouseDown = false;
                slingshotLine.style.display = 'none'; 
                
                if (currentTool === 'pan') {
                    container.style.cursor = 'grab';
                }
                
                if (isDraggingSlingshot) {
                    const startX = parseFloat(slingshotLine.getAttribute('x1'));
                    const startY = parseFloat(slingshotLine.getAttribute('y1'));
                    
                    const rect = container.getBoundingClientRect();
                    const endX = e.clientX - rect.left;
                    const endY = e.clientY - rect.top;
                    
                    const vX = (startX - endX) * SLINGSHOT_POWER / viewport.scale;
                    const vY = (startY - endY) * SLINGSHOT_POWER / viewport.scale;
                    
                    selectedBody.vx = vX;
                    selectedBody.vy = vY;
                    
                    unlockAchievement('slingshot', '*wind noises or something*');
                    
                    isDraggingSlingshot = false;
                }
            });
            
            container.addEventListener('mouseleave', () => {
                isMouseDown = false;
                isDraggingSlingshot = false;
                slingshotLine.style.display = 'none'; 
                if (currentTool === 'pan') {
                    container.style.cursor = 'grab';
                }
            });
            
            
            // --- Simulation Control Listeners ---
            
            pauseBtn.addEventListener('click', () => {
                isPaused = !isPaused; 
                if (isPaused) {
                    pauseBtn.innerHTML = '‚ñ∫'; 
                    pauseBtn.title = 'Resume';
                    unlockAchievement('za_warldo', 'ZA WORLDO!');
                } else {
                    pauseBtn.innerHTML = '‚ùö‚ùö'; 
                    pauseBtn.title = 'Pause';
                    requestAnimationFrame(simulationLoop);
                }
            });
            
            speedUpBtn.addEventListener('click', () => {
                timeScale += timeScaleStep;
                updateSpeedDisplay();
                unlockAchievement('time_warp', 'Time warp');
            });
            
            slowDownBtn.addEventListener('click', () => {
                if (timeScale > timeScaleStep) { 
                    timeScale -= timeScaleStep;
                } else {
                    timeScale = timeScaleStep; 
                }
                updateSpeedDisplay();
                unlockAchievement('time_warp', 'Time warp');
            });
            
            function updateSpeedDisplay() {
                speedDisplay.textContent = `Speed: ${timeScale.toFixed(2)}x`;
            }

            // Zoom Button Listeners
            zoomInBtn.addEventListener('click', () => {
                let newScale = viewport.scale + ZOOM_STEP * viewport.scale;
                viewport.scale = Math.min(newScale, 20.0); // Clamp max zoom
                updateZoomDisplay();
                renderGalaxy(); // Re-render even if paused
            });
            
            zoomOutBtn.addEventListener('click', () => {
                let newScale = viewport.scale - ZOOM_STEP * viewport.scale;
                viewport.scale = Math.max(0.05, newScale); // Clamp min zoom
                updateZoomDisplay();
                renderGalaxy(); // Re-render even if paused
            });

            function updateZoomDisplay() {
                zoomDisplay.textContent = `Zoom: ${viewport.scale.toFixed(1)}x`;
            }


            // === 6. START THE SIMULATOR ===
            populateLoadMenu();
            loadAchievements(); // Load saved achievements
            updateAddForm(); 
            requestAnimationFrame(simulationLoop); 
        });
    </script>

</body>
</html>
